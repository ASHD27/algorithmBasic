/*
    DP 를 이용한 이항 계수 (Binomial Coefficient) 구하기 
    
    이항 계수의 본래 공식은 아래와 같다
    nCk = n!/k!(n-k)! (0 <= k <= n)

    팩토리얼 연산은 계산량이 보통 많다
    그래서 이런 이항 계수 연산을 할 때 어떻게 하면 팩토리얼을 사용하지 않고
    이항 계수를 구할 수 있을까?
    이 공식을 사용하면 그 답을 얻을 수 있다

    n       n - 1   n - 1
        =         +   
    k       k - 1     k
    (0 < k < n 일때)
    k 가 0 이거나 n 이면 1임

    여기서는 (n k) 를 구하는게 목적임
    이 이항 계수에 대한 재귀함수를 이용한 코드는 아래와 같이 요약됨
    int bin(int n, int k) {
        if (k == 0 || k == n) 
            return 1
        else
            return bin(n-1, k-1) + bin(n-1, k);
    }

    근데 이건 DP 에 부합한다고 볼 수는 없음
    DP 의 핵심은 중복된 작은 문제에 대한 연산을 피하는 것임
    위와 같은 코드는 Divide and Conquer 라 불러야 맞음

    DP 의 핵심을 구현하기 위해서 필요한 도구는 바로
    Memoization 임 
    이미 작은 문제에서 계산된 내용을 저장해두는 방법

    이 이항 계수에선 이차원 배열을 만들고 저장하게 만듬
    B[n][k] = nCk 가 됨.
    이를 관계식으로 나타내면
    B[n][k] = B[n-1][k-1] + B[n-1][k] (단 0 < k < n 일때)
    B[n][k] = 1 (단, k = 0 또는 k = n)

    이차원 배열을 활용한 이항계수 값을 저장할 때 참조할 만한 것은
    Pascal 의 삼각형 이란게 있다.
    이건 B[n][k] = B[n-1][k-1] + B[n-1][k] 인 점에서 착안하여 만든 삼각형이다.
    1
    1 1
    1 2 1
    1 3 3 1 ...
    이렇게 이항 계수 이차원 배열이 형성되는데,
    2 값을 보면 B[2][1] = B[1][1] + B[1][0] 으로 구성 된것을 알 수 있다
    이런 것을 파스칼의 삼각형 이라 한다.

    아래에 직접 DP 를 이용한 이항 계수 값을 구하는 코드를 써보자
*/

#include <stdio.h>
#define MIN(A, B) A < B ? A : B

int B[10][10];

int bin(int n, int k) // n 은 행, k 는 열
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < MIN(i, k); j++)
        {
            if (j == 0 || j == i)
            {
                return B[i][j] = 1;
            }
            else
            {
                return B[i][j] = B[i - 1][j - 1] + B[i - 1][j];
            }
        }
    }
}

int main()
{
    int result = bin(5, 5);
    printf("%d", result);
    return 0;
}

/*
    이 코드에 대한 시간 복잡도를 분석해보면,
    단위 연산을 하는 것은 두번째 for 문 내의 문장들이며,
    입력의 크기는 n 과 k 이다.

    첫번째 for 문에 대한 변수인 i 가 증가할 때 마다 j 루프의 수행 횟수를 파악해보면,
    i 가 0 이면, j 루프 실행 횟수는 1
    i 가 1 이면, j 루프 실행 횟수는 2
    ...
    i 가 k 이면, j 루프 실행 횟수는 k + 1
    i 가 k + 1 이면, j 루프 실행 횟수는 k + 1
    ..
    i 가 n 이면, j 루프 실행 횟수는 k + 1
    
    왜 i 가 k 이후에도 j 루프 실행 횟수가 k + 1 일까?

    그것은 열의 최대 값이 k 이기 때문이다.
    
    그래서 전체 시행 횟수를 계산해 보면,
    1 + 2 + 3 + ... + k + (k + 1) + (k + 1) + ... (k + 1)
    이며 (k + 1) 은 n-k+1 번 나타난다 볼 수 있다
    1 ~ k 까지의 합은 
    k(k+1)/2 이고 나머지 (k + 1) 부분은 (n-k+1)(k+1)
    이므로
    (2n-k+2)(k+1)/2 가 되고
    빅오로 나타내면 O(nk) 가 된다

    이중 포문을 사용하긴 했지만, 
    DP 방식을 사용했기 때문에, O(n^2) 보다는 적은 값을 도출 할 수 있다.  
*/
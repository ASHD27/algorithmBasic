/*
    계수 정렬(counting sort)
    여태까지 선택정렬, 삽입정렬, 버블정렬, 퀵정렬, 병합정렬, 힙정렬을 공부했는데,
    이 6개의 정렬법 중 가장 빠른 것은 O(N*logN) 이 나오는 퀵정렬,병합정렬,힙정렬이었다.
    근데 이것 보다 더 빠르게 정렬을 할 필요가 있을 경우 쓰이는게 Counting sort 이다.
    
    계수 정렬에는 한가지 조건이 있는데,
    그건 바로 입력으로 주어진 값이 '범위조건' 이 있는 경우에 한해서만 빠르게 작용하는 정렬 알고리즘 이라는 것.
    가장 빠를때는 심지어 O(N) 이 나오기도 함.
    계수 정렬의 가장 기본 개념은 '크기를 기준으로 갯수를 세자' 이다.

    예시로, 입력이 다음과 같이 주어진다하자
    1 3 2 4 3 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1
    (5이하의 자연수만 입력으로 들어온 경우)

    기준이 5이하의 자연수라고 주어진 문제이므로,
    각 크기별 갯수를 먼저 카운팅 한다
    무슨말이냐면, 1은 8개, 2는 6개 .. 이런식으로 카운팅을 한다는 의미

    계수정렬 이전의 정렬 알고리즘들은 입력 데이터 그 자체의 위치를 바꾸는 방식이었다면,
    이 계수정렬은 위치를 바꿀 필요없이 오로지 그냥 카운팅만 하면 되는 그런 알고리즘
    그래서 O(N) 인듯, 한번만 쭉 순차 탐색하면 되기 때문에.

    5이하의 자연수라 했으므로, 배열의 크기가 5인 배열을 하나 만들고,
    입력값에 대한 순차탐색을 돌린다음
    1 이 나오면 첫번째 인덱스 값 하나 증가, 2 가 나오면 두번째 하나 증가
    이런식으로 쭉 가서 다 증가를 시키면 각각의 갯수를 파악하게 됨.
    이렇게 갯수를 알았으니, 각 인덱스에 접근할때마다 그 갯수만 큼 출력하면 끝
    1이 8개 이므로 1을 8번출력하고,
    2가 6개 이므로 2를 6번출력하고, 이런식으로 하면 그냥 오름차순정렬 끝
*/

#include <iostream>

using namespace std;

int main()
{
    int temp;
    int count[5];
    int array[30] = {
        1, 3, 2, 4, 3, 2, 5, 3, 1, 2,
        3, 4, 4, 3, 5, 1, 2, 3, 5, 2,
        3, 1, 4, 3, 5, 1, 2, 1, 1, 1};
    for (int i = 0; i < 5; i++)
    {
        count[i] = 0;
    }
    for (int i = 0; i < 30; i++)
    {
        count[array[i] - 1]++;
    }
    for (int i = 0; i < 5; i++)
    {
        if (count[i] != 0) // 카운팅 한 값이 0 이 아니라면
        {
            for (int j = 0; j < count[i]; j++)
            {
                // 카운팅된 값 만큼 해당 값을 출력
                cout << i + 1 << ' ';
            }
        }
    }
    return 0;
}

/*
    오늘 알아낸 사실
    1. 1이 몇개, 2가 몇개 이런 식의 카운팅을 할때,
    멍청하게 if 쭉 나열할 생각하지말고, 
    count[array[i] - 1]++; 처럼 인덱스 접근시에 카운팅 + 1
    으로 코드를 작성해라 (제발 잘 좀 하자)
    2. 계수정렬은 제한조건에 영향을 받기때문에
    제한조건이 매우 적은 범위에서만 효율적이다.
    제한조건이 존나 크면 차라리 다른 정렬 법을 쓰는게 낫다
    
*/
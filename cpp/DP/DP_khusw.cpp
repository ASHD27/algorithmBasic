/*
    DP (Dynamic Programming)
    DP 란 하나의 문제는 단 한번만 풀어라 가 기본 개념.
    한 번 이미 푼 내용을 또 다시 푸는 비효율성을 제거하기 위한 알고리즘 이다.

    피보 나치 수열을 분할 정복 기법을 이용해서 문제를 풀 경우,
    예를 들어 뭐 10 번째 피보나치 수열을 구한다 치면
                    10
            9               8
        8       7       7       6              
    7       6        6      5       .....
    이렇게 위에서 이미 계산한 수 들이 아래에서 또 나오는 문제가 존재함

    (피보나치는 통상 재귀로 계산하는데 그 때 이런 문제가 발생)

    DP 를 사용하기 위한 가정 두 가지
    1. 큰 문제를 작은 문제로 나눌 수 있다.
    2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

    이미 계산을 완료한 문제는 메모이제이션을 사용하여
    계산이 이미된 결과는 배열에 저장한다.
*/

#include <stdio.h>

int d[100]; // 메모이제이션을 위한 배열 변수
// 전역 변수는 초기화에 아무 값도 주지 않으면 0이 들어감

int dp(int x)
{
    if (x == 1) // 1, 2 는 재귀함수의 종료 조건
        return 1;
    if (x == 2)
        return 1;
    if (d[x] != 0) // 0 이 아니라는 것은 연산후 값이 들어 갔다는 것.
                   // 즉 이미 연산을 완료한 부분의 값이므로 그대로 리턴
        return d[x];
    return d[x] = dp(x - 1) + dp(x - 2);
}

int main()
{
    printf("%d", dp(5));
}

/*
    DP 를 활용한 피보나치 수열의 시간복잡도는?
    O(N) 이다.
    왜냐하면, 들어온 입력의 값 N 을 높이로 하는 것만큼만
    연산을 수행하기 때문이다.

    DP 를 쓰지 않고 그냥 재귀함수를 사용하게 되면
    O(2^N) 이 소요된다.
    높이 N 너비 2의 배수 만큼 증가하기 때문이다.

    DP 의 장점은 바로 메모이제이션 기법을 쓰기 때문에
    시간복잡도를 확 줄일수 있다는 것이다.
*/
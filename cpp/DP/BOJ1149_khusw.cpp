/*
    BOJ 1149 RGB 거리
    https://www.acmicpc.net/problem/1149 

    RGB 거리라는 일직선으로 된 길가에 집들이 나열되어 있는데
    각 집은 빨강 초록 파랑 중 하나의 색으로 칠해져야 하며,
    아래와 같은 조건으로 색이 칠해져야함

    1. 1번집은 2번집의 색과 달라야함
    2. N번집은 N-1번집의 색과 달라야함
    3. i(2 <= i <= N - 1) 번 집의 색은 i - 1 번, i + 1 번 집의 색과 달라야함.

    결국 양옆에 있는 집들이 서로 다른 색으로 칠해져야만 한다는 뜻.
    (주의 할 점은 집들이 모두 서로가 다른 색이 아니라 인접한 대상만 다른 색이어야함.)

    입력 N 은 집의 숫자가 주어지고, N 은 2 ~ 1000 이며,
    두번째 줄 입력 부터는 빨강 초록 파랑 으로 칠하는 비용이 주어짐 (한줄당 한집)
    칠하는 비용은 1000 이하의 자연수.

    이때 출력은 모든 집을 색 칠함에 있어서 최소의 비용만을 찾아서 칠하는 경우의 수를 출력해야함.
*/

#include <iostream>
#include <algorithm>

using namespace std;

int N;
int adj[1001][3]; // 행은 집의 갯수, 열은 RGB 3개 값
int D[1001][3];   // 거리를 담는 이차원 배열

void find_min_value()
{
    for (int i = 1; i <= N; i++)
    {
        D[i][0] = min(D[i - 1][1], D[i - 1][2]) + adj[i][0];
        D[i][1] = min(D[i - 1][0], D[i - 1][2]) + adj[i][1];
        D[i][2] = min(D[i - 1][0], D[i - 1][1]) + adj[i][2];
    }

    int minimum;
    minimum = min(min(D[N][0], D[N][1]), D[N][2]);
    cout << minimum;
}

int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    cin >> N;

    for (int i = 1; i <= N; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            cin >> adj[i][j];
        }
    }

    find_min_value();

    return 0;
}

/*
    이 문제에 대한 점화식은 아래와 같이 서술 된다.

    먼저 거리를 담고 있는 이차원 배열 D[][] 를 선언하고 

    해당 집의 거리를 계산하기 위해서는

    D[i][0] = min(D[i - 1][1], D[i - 1][2]) + adj[i][0]
    D[i][1] = min(D[i - 1][0], D[i - 1][2]) + adj[i][1]
    D[i][2] = min(D[i - 1][0], D[i - 1][1]) + adj[i][2]

    위와 같은 식을 사용해야 한다.

    이 식의 의미가 무엇인가 하면,

    D[i][0] = min(D[i - 1][1], D[i - 1][2]) + adj[i][0] 의 경우
    i 번째의 집이 빨강색(열로 따지면 0 번째 인덱스임) 을 칠할때의 거리값은 
    이전 번째의 집 i - 1 의 초록색(열로 따지면 1번째 인덱스), 파랑색(열로 따지면 2번째 인덱스) 중 최소값을 잡아서 
    현재 i 번째의 빨강색(열로 따지면 0번째 인덱스) 의 값과 누적해나가는 방식이다.

    양옆의 색깔이 서로 겹쳐서는 안되기 때문에 min 함수를 사용할때, 서로 다른 두개의 열 인덱스를 참조해서 최소값을 꺼낸뒤
    현재 i 번째 인덱스의 거리 값을 더해서 총 누적거리를 알 수 있는 것이다.

    그리고 전체를 다 누적하게 되면
    마지막 행에 빨강색, 초록색, 파랑색 각각의 누적값이 계산되어 있으며,
    마지막 행에서의 최소값만 추출하면 결국 전체 최소 값을 알 수 있게 된다.

    ** 주의할점
    매크로함수 #define MIN(A, B) A > B ? B : A 로 정의할 경우
    반복적으로 사용할 수 없다.
    아마도 매크로 함수는 한번만 사용이 가능한듯 하다.
*/
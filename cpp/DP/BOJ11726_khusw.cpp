/*
    DP(Dynamic Programing) 중 타일링 문제.
    DP 에서 가장 기본 기법이라 취급되는 Tiling 문제를 풀어본다.
    DP 에서 가장 기본이라는 거지 무작정 쉬운 문제는 아님
    이런 류의 문제를 풀때는
    먼저 문제를 깊게 이해하고, 그 다음, 점화식을 세워보고
    문제를 풀어야 답을 맞출 수 있음

    BOJ 11726번 2*n 타일링
    https://www.acmicpc.net/problem/11726

    2*n 크기의 직사각형을 
    1*2, 2*1 타일로 채우는 방법의 수를 구하는 문제
    문제에서는 n 을 1 ~ 1000 까지로 잡아줬고
    이런 문제의 경우 n = 1, n = 2 .. 각 순서대로
    한 번 직접 그려보던지, 점화식을 세우던지 해야 문제가 풀림

    각 경우의 수를 노트에 그려서 확인.

    DP 문제들은 주어진 문제에서 
    규칙성을 발견해서 
    그 규칙성에 맞는 점화식을 세워서 문제를 풀어야 문제가 풀림

    메모이제이션 (반복될때 값을 저장하는 공간)

    이 BOJ 11726번 문제는 
    일반화를 시켰을때, 결국에는 피보나치 수열과 동일하게 진행됨을 알 수 있다.
    D(N) = D(N - 1) + D(N - 2) 인것.
*/

#include <stdio.h>

int d[1001]; // memoization 을 위한 배열 변수

int dp(int x)
{
    if (x == 1)
        return 1;
    if (x == 2)
        return 2;
    if (d[x] != 0)
        return d[x];
    return d[x] = (dp(x - 1) + dp(x - 2)) % 10007;
    // 10007 로 나눈 나머지를 리턴하는 이유는
    // 문제의 출력 조건에 10007로 나눈 나머지를 출력하라고 언급되어있기 때문
    // 이런 문제에서 제시한 수로 나눈 이유는 dp 재귀함수를 사용할때
    // 값이 무한정 커져서 오버플로우가 발생하는 상황을 예방하기 위함이라고한다.
}

int main()
{
    int x;
    scanf("%d", &x);
    printf("%d", dp(x));
    return 0;
}
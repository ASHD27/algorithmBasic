/*
    다익스트라(Dijkstra) 알고리즘

    다익스트라 알고리즘은 DP 를 활용한 대표적인 최단 경로 탐색 알고리즘이다.
    GPS 등에서 주로 사용됨.

    이 다익스트라 알고리즘은 어떤 하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 알려줌.
    (가정 : 간선의 가중치 값은 음수가 될 수 없다)

    (교재에 따라서 다르긴 하지만, 다익스트라를 Greedy 로 취급하는 경우도 있음.)

    다익스트라 알고리즘인 DP 인 이유는 
    "최단 거리는 여러 개의 최단 거리로 이뤄져 있기 때문이다."
    작은 문제가 큰 문제의 부분 집합에 속해 있기 때문이다.
    -어떤 하나의 최단 거리를 구할때 그 이전까지 구했던 최단 거리 정보를 그대로 사용하는 특징이 있다.
*/

#include <stdio.h>

int number = 6;
int INF = 1000000000; // 무한대를 표현하기 위한 변수를 int 의 거의 끝 값으로

// 전체 그래프를 초기화
int a[6][6] = {
    {0, 2, 5, 1, INF, INF},
    {2, 0, 3, 2, INF, INF},
    {5, 3, 0, 3, 1, 5},
    {1, 2, 3, 0, 1, INF},
    {INF, INF, 1, 1, 0, 2},
    {INF, INF, 5, INF, 2, 0}};

bool v[6]; // 방문한 노드인지 판별하기 위한 배열, bool 타입은 전역변수로 선언시 0 으로 초기화 (False)
int d[6];  // 거리를 나타내는 배열

// 가장 최소 거리를 가지는 정점을 반환하는 함수 생성
// 남은 노드 중 비용이 가장 적은 노드를 리턴하는 함수
int getSmallIndex()
{
    int min = INF; // 최소값을 나타내는 변수
    int index = 0; // 인덱스 값을 저장하는 변수
    for (int i = 0; i < number; i++)
    { // 순차탐색으로 전체 돌기
        if (d[i] < min && !v[i])
        {
            // i 번째의 거리가 최소값 보다 작고
            // i 번째를 방문했다면,
            // d[i] 가 최소값이고, i 가 그 최소값의 인덱스가 됨
            min = d[i];
            index = i;
        }
    }
    return index;
}

// 다익스트라를 수행하는 함수
void dijkstra(int start) // start 시작할 노드 번호
{
    // start 를 0 주면 1번 노드에서 시작, 1주면 2번 노드에서 시작 ...
    for (int i = 0; i < number; i++)
    {
        d[i] = a[start][i]; // 시작 노드의 행 기준으로 거리 갱신
        // start 에 해당하는 노드의 행으로만 거리를 따지고 갱신함 (2차원 배열 전체를 수정하는게 아님)
    }
    v[start] = true; // 시작 노드를 방문하였으므로 True 로 지정
    // 위에 까지는 시작 행을 설정하고 시작 노드의 방문 여부를 설정해 줬다면 (초기화 작업)

    // 아래 부터는 초기화 작업이 아니라, 최소 값을 찾아서 본격적으로 비교를 하는 알고리즘
    for (int i = 0; i < number - 2; i++)
    {
        int current = getSmallIndex(); // start 행을 기준으로 가장 작은 값의 인덱스를 받아옴
        v[current] = true;             // 그리고 가장 작은 값이 속한 곳은 방문 했다고 처리함 (여기서 부터 시작하므로)
        for (int j = 0; j < 6; j++)
        {
            if (d[current] + a[current][j] < d[j] && !v[j])
            {
                // 예를 들어서, 블로그 그림처럼 그래프가 있을 때,
                // 1에서 출발해서 3 간다고 할 때,
                // 1 -> 3 직통은 5의 비용이 소모되지만,
                // 1 -> 4 -> 3 은 1 + 3 = 4 의 비용이 소모된다.
                // 이 때 d[j] 가 바로 5 가 되고,
                // d[current] 가 1 -> 4 로 갈때의 비용이고,
                // a[current][j] 가 4 -> 3 로 갈때의 비용을 의미한다.
                // 그러므로 직통 보다 작은경우 더 적은 값으로 갱신 되도록
                // d[j] 를 우변의 값으로 바꾼 것이다.
                d[j] = d[current] + a[current][j];
            }
        }
    }
}

int main()
{
    dijkstra(0);
    for (int i = 0; i < number; i++)
    {
        printf("%d ", d[i]);
    }
    return 0;
}

/*
    위의 코드는 다익스트라를 구현하기 위해서 순차 탐색을 이용했는데
    이 순차탐색을 이용할 때, 시간 복잡도는 O(N^2) 으로 소요된다.
    그래서 실제 PS 문제 풀때 이 방법을 쓰면, 
    시간 초과 오류가 날 가능성이 상당히 크다.
    힙을 사용하게 되면 (힙 정렬에서도 봤지만)
    시간 복잡도가 O(logN) 으로 소요된다 (가장 큰게 위로 오게 하거나 (MaxHeap),
    가장 작은게 위로 오게 하거나 (MinHeap) 할 때, 높이의 절반 만큼 고려하기 때문, 힙 정렬 참조)
    그래서 getSmallIndex() 함수를 쓸 때, 지금 처럼 순차 탐색을 쓰지 말고,
    힙 정렬을 활용해서 문제를 푼다면 시간 초과 오류는 만나지 않게 된다.

    만약에, 노드 수만 많은데, 연결된 간선의 수 자체는 매우 적은 경우
    (예를 들면, 노드 수는 백만개, 간선 수는 2개 이럴 때)
    위 코드는 순차 탐색을 쓰기 때문에 백만 * 백만 의 연산을 수행해야함
    
*/